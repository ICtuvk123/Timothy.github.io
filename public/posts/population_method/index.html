<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Population Method | Timothy&#39;s Blog</title>
<meta name="keywords" content="Programming, Population Method, Mathematical Modeling">
<meta name="description" content="An in-depth look at the Population Method">
<meta name="author" content="Timothy">
<link rel="canonical" href="http://localhost:1313/posts/population_method/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2dd7dd100f06b24f3d68c8d71d9065e5e0088bb70c9dac5b8f73c34ee1661edb.css" integrity="sha256-LdfdEA8Gsk89aMjXHZBl5eAIi7cMnaxbj3PDTuFmHts=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/population_method/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"
    onload="renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        throwOnError: false
    });"></script>
<meta property="og:url" content="http://localhost:1313/posts/population_method/">
  <meta property="og:site_name" content="Timothy&#39;s Blog">
  <meta property="og:title" content="Population Method">
  <meta property="og:description" content="An in-depth look at the Population Method">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-16T10:00:00+08:00">
    <meta property="article:modified_time" content="2026-01-16T10:00:00+08:00">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Population Method">
    <meta property="article:tag" content="Mathematical Modeling">
    <meta property="og:image" content="http://localhost:1313/picture/population_cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/picture/population_cover.png">
<meta name="twitter:title" content="Population Method">
<meta name="twitter:description" content="An in-depth look at the Population Method">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Population Method",
      "item": "http://localhost:1313/posts/population_method/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Population Method",
  "name": "Population Method",
  "description": "An in-depth look at the Population Method",
  "keywords": [
    "Programming", "Population Method", "Mathematical Modeling"
  ],
  "articleBody": "This post presents a variety of population methods that involve optimization using a collection of design points, called individuals.\nHaving a large number of individuals distributed throughtout the design space can help the algorithm to explore the design space more effectively.\nMany population methods are stochastica in nature, and it is generally easy to parallelize the computation.\nPopulation Iteration population iteratively improve a population of m designs\n$$\rx^{(1)}, x^{(2)}, \\dots, x^{(m)}\r$$\rThe population at a particular iteration is represented as a generation.\nThe algorithms are designed so that the individuals in the population converge to one or more local minima over multiple generations.\nThe various methods discussed in this post differ in how they generate a new generation from the current generation.\nPopulation mehtods begin with an initial population, which is often generated randomly.The initial population should be spread over the design space to encourage exploration.\nabstract type PopulationMethod end function population_method(M::PopulationMethod, f, desings, k_max) population = init!(M,f,designs) for k in 1:k_max population = iterate!(M, f, population) end return population end The following are there distributions used to generate the initial population:\nUniform Distribution Normal Distribution Cauchy Distribution Genetic Algorithm The genetic algorithm is inspired by the process of natural selection in biological evolution.\nThe design point associated with each individual is represented as a chromosome. At each generation, the chromosomes of the fitter individuals are passed on to the next generation through selection, crossover, and mutation operations.\nstruct GeneticAlgorithm \u003c: PopulationMethod S # SelectionMethod C # CrossoverMethod U # MutationMethod end init!(M::GeneticAlgorithm, f, designs) = designs function step!(M::GeneticAlgorithm, f, population) S, C, U = M.S, M.C, M.U parents = select(S, f.(population)) children = [crossover(C,population[p[1]],population[p[2]]) for p in parents] return [mutate(U, c) for c in children] end Selection Selection chooses individuals from the current population to serve as parents for the next generation. Common selection methods include rank-based selection, tournament selection, and roulette wheel selection.\nrank-based selection sorts individuals based on their fitness and assigns selection probabilities accordingly. tournament selection randomly selects a subset of individuals and chooses the fittest among them as parents. roulette wheel selection assigns selection probabilities proportional to fitness, allowing fitter individuals a higher chance of being selected. abstract type SelectionMethod end # Pick pairs randomly from top k parents struct TruncationSelection \u003c: SelectionMethod k # top k to keep end function select(t::TruncationSelection, y) p = sortperm(y) return [p[rand(1:t.k, 2)] for i in y] end # Pick parents by choosing best among random subsets struct TournamentSelection \u003c: SelectionMethod k # top k to keep end function select(t::TournamentSelection, y) getparent() = begin p = randperm(length(y)) p[argmin(y[p[1:t.k]])] end return [[getparent(), getparent()] for i in y] end # Sample parents proportionately to fitness struct RouletteWheelSelection \u003c: SelectionMethod end function select(::RouletteWheelSelection, y) y = maximum(y) .- y cat = Categorical(normalize(y, 1)) return [rand(cat, 2) for i in y] end Crossover Crossover combines the chromosomes of parents to form children. As with selection, there are several crossover schemes\nIn single-point crossover, a random crossover point is selected, and the segments of the parents’ chromosomes are swapped to create children. In two-point crossover, two crossover points are selected, and the segments between these points are exchanged. In uniform crossover, each gene is independently chosen from one of the parents with equal probability. abstract type CrossoverMethod end struct SinglePointCrossover \u003c: CrossoverMethod end function crossover(::SinglePointCrossover, a, b) i = rand(eachindex(a)) return [a[1:i]; b[i+1:end]] end struct TwoPointCrossover \u003c: CrossoverMethod end function crossover(::TwoPointCrossover, a, b) n = length(a) i, j = rand(1:n, 2) if i \u003e j (i,j) = (j,i) end return [a[1:i]; b[i+1:j]; a[j+1:n]] end struct UniformCrossover \u003c: CrossoverMethod p # crossover probability end function crossover(U::UniformCrossover, a, b) return [rand() \u003e U.p ? u : v for (u,v) in zip(a,b)] end struct InterpolationCrossover \u003c: CrossoverMethod λ # interpolant end crossover(C::InterpolationCrossover, a, b) = (1-C.λ)*a + C.λ*b Mutation Mutation introduces random changes to individuals to maintain genetic diversity within the population. Common mutation method is zero-mean Gaussian distribution.\nabstract type MutationMethod end struct DistributionMutation \u003c: MutationMethod λ # mutation rate D # mutation distribution end function mutate(M::DistributionMutation, child) return [rand() \u003c M.λ ? v + rand(M.D) : v for v in child] end GaussianMutation(σ) = DistributionMutation(1.0, Normal(0,σ)) Each gene in the chromosome typically has a small probability λ of being changed. For a chromosome with m genes, this mutation rate is typically set to λ = 1/m, yielding an average of one mutation per child chromosome.\nDifferential Evolution Differential Evolution (DE) is a population-based optimization algorithm that utilizes vector differences for perturbing the population members.\nFor each individual x:\nSelect three distinct individuals a, b, and c from the population. Generate a trial vector by adding the weighted difference between b and c to a: $$ v = a + F \\cdot (b - c) $$ where F is a scaling factor typically in the range [0, 2]. Evaluate the fitness of the trial vector v. If v has a better fitness than x, replace x with v in the next generation; otherwise, retain x. mutable struct DifferentialEvolution \u003c: PopulationMethod p # crossover probability w # differential weight end init!(M::DifferentialEvolution, f, designs) = designs function step!(M::DifferentialEvolution, f, population) p, w = M.p, M.w n, m = length(population[1]), length(population) for x in population a, b, c = sample(population, 3, replace=false) z = a + w*(b-c) x′ = crossover(UniformCrossover(p), x, z) if f(x′) \u003c f(x) x .= x′ end end return population end Particle Swarm Optimization Particle swarm optimization introduces momentum to accelerate convergence toward minima. Each individual, or particle, in the population keeps track of its current position, velocity, and the best position it has seen so far. Momentum allows an individual to accumulate speed in a favorable direction, independent of local perturbations.\nAt each iteration, each individual is accelerated toward both the best position it has seen and the best position found thus far by any individual. The acceleration is weighted by a random term.\nmutable struct Particle x # position v # velocity x_best # best design thus far end mutable struct ParticleSwarm \u003c: PopulationMethod w # inertia c1 # first momentum coefficient c2 # second momentum coefficient V # initial particle velocity distribution best # best overall design thus far, and its value end function init!(M::ParticleSwarm, f, designs) population = [Particle(x,rand(M.V),copy(x)) for x in designs] best = (x=copy(population[1].x), y=Inf) for P in population y = f(P.x) if y \u003c best.y; best = (x=P.x, y=y); end end M.best = best return population end function step!(M::ParticleSwarm, f, population) w, c1, c2, best = M.w, M.c1, M.c2, M.best n = length(best.x) for P in population r1, r2 = rand(n), rand(n) P.x += P.v P.v = w*P.v + c1*r1.*(P.x_best - P.x) + c2*r2.*(best.x - P.x) y = f(P.x) if y \u003c best.y; best = (x=copy(P.x), y=y); end if y \u003c f(P.x_best); P.x_best .= P.x; end end M.best = best return population end Firefly Algorithm The firefly algorithm was inspired by the manner in which fireflies flash their lights to attract mates of the same species. In the firefly algorithm, each individual in the population is a firefly and can flash to attract other fireflies.\nAt each iteration, all fireflies are moved toward all more attractive fireflies. A firefly’s attraction is proportional to its performance.\nstruct Firefly \u003c: PopulationMethod α # walk step size β # source intensity brightness # intensity function end init!(M::Firefly, f, designs) = designs function step!(M::Firefly, f, population) α, β, brightness = M.α, M.β, M.brightness m = length(population[1]) N = MvNormal(I(m)) for a in population, b in population if f(b) \u003c f(a) r = norm(b-a) a .+= β*brightness(r)*(b-a) + α*rand(N) end end return population end Cuckoo Search Cuckoo search is another nature-inspired algorithm named after the cuckoo bird, which engages in a form of brood parasitism. Cuckoos lay their eggs in the nests of other birds.\nIn cuckoo search, each nest represents a design point. New design points can be produced using Lévy flights from nests, which are random walks with step-lengths from a heavy-tailed distribution (typically a Cauchy distribution).\nmutable struct CuckooSearch \u003c: PopulationMethod p_s # search fraction p_a # nest abandonment fraction C # flight distribution end function init!(M::CuckooSearch, f, designs) return [(x=x, y=f(x)) for x in designs] end function step!(M::CuckooSearch, f, population) p_s, p_a, C = M.p_s, M.p_a, M.C m, n = length(population), length(population[1].x) m_search = round(Int, m*p_s) m_abandon = round(Int, m*p_a) for i in 1:m_search j, k = rand(1:m), rand(1:m) x = population[j].x + rand(C,n) y = f(x) if y \u003c population[k].y population[k] = (x=x, y=y) end end p = sortperm(population, by=nest-\u003enest.y, rev=true) for i in 1:m_abandon j = rand(1:m-m_abandon)+m_abandon x′ = population[p[j]].x + rand(C,n) population[p[i]] = (x=x′, y=f(x′)) end return population end Hybrid Methods Many population methods perform well in global search, being able to avoid local minima and finding the best regions of the design space. Unfortunately, these methods do not perform as well in local search in comparison to descent methods.\nSeveral hybrid methods have been developed to extend population methods with descent-based features to improve their performance in local search.\nIn Lamarckian learning, the population method is extended with a local search method that locally improves each individual. The original individual and its objective function value are replaced by the individual’s optimized counterpart. In Baldwinian learning, the same local search method is applied to each individual, but the results are used only to update the individual’s objective function value. Individuals are not replaced but are merely associated with optimized objective function values. Summary Population methods are powerful optimization techniques that leverage a collection of design points to explore the design space effectively. By utilizing mechanisms inspired by natural processes, such as genetic algorithms, differential evolution, and particle swarm optimization, these methods can navigate complex landscapes and avoid local minima. Hybrid approaches that combine population methods with local search techniques further enhance their performance, making them versatile tools for solving a wide range of optimization problems.\n",
  "wordCount" : "1640",
  "inLanguage": "en",
  "image":"http://localhost:1313/picture/population_cover.png","datePublished": "2026-01-16T10:00:00+08:00",
  "dateModified": "2026-01-16T10:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Timothy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/population_method/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Timothy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Timothy&#39;s Blog (Alt + H)">Timothy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="http://localhost:1313/zh/" title="中文"
                                aria-label="中文">Zh</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Population Method
    </h1>
    <div class="post-description">
      An in-depth look at the Population Method
    </div>
    <div class="post-meta"><span title='2026-01-16 10:00:00 +0800 CST'>January 16, 2026</span>&nbsp;·&nbsp;<span>Timothy</span>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="http://localhost:1313/picture/population_cover.png" alt="Population Method Diagram">
        <figcaption>An overview of various population methods in optimization</figcaption>
</figure>
  <div class="post-content"><p>This post presents a variety of population methods that involve optimization using a collection of design points, called individuals.</p>
<p>Having a large number of individuals distributed throughtout the design space can help the algorithm to explore the design space more effectively.</p>
<p>Many population methods are stochastica in nature, and it is generally easy to parallelize the computation.</p>
<h2 id="population-iteration">Population Iteration<a hidden class="anchor" aria-hidden="true" href="#population-iteration">#</a></h2>
<p>population iteratively improve a population of m designs</p>
<div>
$$
x^{(1)}, x^{(2)}, \dots, x^{(m)}
$$
</div>
<p>The population at a particular iteration is represented as a generation.</p>
<p>The algorithms are designed so that the individuals in the population converge to one or more local minima over multiple generations.</p>
<p>The various methods discussed in this post differ in how they generate a new generation from the current generation.</p>
<p>Population mehtods begin with an initial population, which is often generated randomly.The initial population should be spread over the design space to encourage exploration.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">abstract type</span> <span style="color:#66d9ef">PopulationMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> population_method(M<span style="color:#f92672">::</span><span style="color:#66d9ef">PopulationMethod</span>, f, desings, k_max)
</span></span><span style="display:flex;"><span>    population <span style="color:#f92672">=</span> init!(M,f,designs)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> k <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>k_max
</span></span><span style="display:flex;"><span>        population <span style="color:#f92672">=</span> iterate!(M, f, population)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> population
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>The following are there distributions used to generate the initial population:</p>
<ul>
<li>Uniform Distribution</li>
<li>Normal Distribution</li>
<li>Cauchy Distribution</li>
</ul>
<p><img alt="Population Initialization" loading="lazy" src="/picture/population_method01.png"></p>
<h2 id="genetic-algorithm">Genetic Algorithm<a hidden class="anchor" aria-hidden="true" href="#genetic-algorithm">#</a></h2>
<p>The genetic algorithm is inspired by the process of natural selection in biological evolution.</p>
<p>The design point associated with each individual is represented as a chromosome. At each generation, the chromosomes of the fitter individuals are passed on to the next generation through selection, crossover, and mutation operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">GeneticAlgorithm</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">PopulationMethod</span>
</span></span><span style="display:flex;"><span>    S <span style="color:#75715e"># SelectionMethod</span>
</span></span><span style="display:flex;"><span>    C <span style="color:#75715e"># CrossoverMethod</span>
</span></span><span style="display:flex;"><span>    U <span style="color:#75715e"># MutationMethod</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>init!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">GeneticAlgorithm</span>, f, designs) <span style="color:#f92672">=</span> designs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> step!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">GeneticAlgorithm</span>, f, population)
</span></span><span style="display:flex;"><span>    S, C, U <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>S, M<span style="color:#f92672">.</span>C, M<span style="color:#f92672">.</span>U
</span></span><span style="display:flex;"><span>    parents <span style="color:#f92672">=</span> select(S, f<span style="color:#f92672">.</span>(population))
</span></span><span style="display:flex;"><span>    children <span style="color:#f92672">=</span> [crossover(C,population[p[<span style="color:#ae81ff">1</span>]],population[p[<span style="color:#ae81ff">2</span>]])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> p <span style="color:#66d9ef">in</span> parents]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [mutate(U, c) <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> children]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><h3 id="selection">Selection<a hidden class="anchor" aria-hidden="true" href="#selection">#</a></h3>
<p>Selection chooses individuals from the current population to serve as parents for the next generation. Common selection methods include rank-based selection, tournament selection, and roulette wheel selection.</p>
<p>rank-based selection sorts individuals based on their fitness and assigns selection probabilities accordingly.
<img alt="Rank-based Selection" loading="lazy" src="/picture/population_method02.png"></p>
<p>tournament selection randomly selects a subset of individuals and chooses the fittest among them as parents.
<img alt="Tournament Selection" loading="lazy" src="/picture/population_method03.png"></p>
<p>roulette wheel selection assigns selection probabilities proportional to fitness, allowing fitter individuals a higher chance of being selected.
<img alt="Roulette Wheel Selection" loading="lazy" src="/picture/population_method05.png"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">abstract type</span> <span style="color:#66d9ef">SelectionMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Pick pairs randomly from top k parents</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">TruncationSelection</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">SelectionMethod</span>
</span></span><span style="display:flex;"><span>    k <span style="color:#75715e"># top k to keep</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> select(t<span style="color:#f92672">::</span><span style="color:#66d9ef">TruncationSelection</span>, y)
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> sortperm(y)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [p[rand(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>t<span style="color:#f92672">.</span>k, <span style="color:#ae81ff">2</span>)] <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> y]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Pick parents by choosing best among random subsets</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">TournamentSelection</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">SelectionMethod</span>
</span></span><span style="display:flex;"><span>    k <span style="color:#75715e"># top k to keep</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> select(t<span style="color:#f92672">::</span><span style="color:#66d9ef">TournamentSelection</span>, y)
</span></span><span style="display:flex;"><span>    getparent() <span style="color:#f92672">=</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> randperm(length(y))
</span></span><span style="display:flex;"><span>        p[argmin(y[p[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>t<span style="color:#f92672">.</span>k]])]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [[getparent(), getparent()] <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> y]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Sample parents proportionately to fitness</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">RouletteWheelSelection</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">SelectionMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> select(<span style="color:#f92672">::</span><span style="color:#66d9ef">RouletteWheelSelection</span>, y)
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> maximum(y) <span style="color:#f92672">.-</span> y
</span></span><span style="display:flex;"><span>    cat <span style="color:#f92672">=</span> Categorical(normalize(y, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [rand(cat, <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> y]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><h3 id="crossover">Crossover<a hidden class="anchor" aria-hidden="true" href="#crossover">#</a></h3>
<p>Crossover combines the chromosomes of parents to form children. As with selection, there are several crossover schemes</p>
<ol>
<li>In single-point crossover, a random crossover point is selected, and the segments of the parents&rsquo; chromosomes are swapped to create children.
<img alt="Single-point Crossover" loading="lazy" src="/picture/population_method06.png"></li>
<li>In two-point crossover, two crossover points are selected, and the segments between these points are exchanged.
<img alt="Two-point Crossover" loading="lazy" src="/picture/population_method07.png"></li>
<li>In uniform crossover, each gene is independently chosen from one of the parents with equal probability.
<img alt="Uniform Crossover" loading="lazy" src="/picture/population_method08.png"></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">abstract type</span> <span style="color:#66d9ef">CrossoverMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">SinglePointCrossover</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">CrossoverMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> crossover(<span style="color:#f92672">::</span><span style="color:#66d9ef">SinglePointCrossover</span>, a, b)
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> rand(eachindex(a))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [a[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>i]; b[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#66d9ef">end</span>]]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">TwoPointCrossover</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">CrossoverMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> crossover(<span style="color:#f92672">::</span><span style="color:#66d9ef">TwoPointCrossover</span>, a, b)
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> length(a)
</span></span><span style="display:flex;"><span>    i, j <span style="color:#f92672">=</span> rand(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> j
</span></span><span style="display:flex;"><span>        (i,j) <span style="color:#f92672">=</span> (j,i)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [a[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>i]; b[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>j]; a[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n]]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">UniformCrossover</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">CrossoverMethod</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#75715e"># crossover probability</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> crossover(U<span style="color:#f92672">::</span><span style="color:#66d9ef">UniformCrossover</span>, a, b)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [rand() <span style="color:#f92672">&gt;</span> U<span style="color:#f92672">.</span>p <span style="color:#f92672">?</span> u <span style="color:#f92672">:</span> v <span style="color:#66d9ef">for</span> (u,v) <span style="color:#66d9ef">in</span> zip(a,b)]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">InterpolationCrossover</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">CrossoverMethod</span>
</span></span><span style="display:flex;"><span>    λ <span style="color:#75715e"># interpolant</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>crossover(C<span style="color:#f92672">::</span><span style="color:#66d9ef">InterpolationCrossover</span>, a, b) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>C<span style="color:#f92672">.</span>λ)<span style="color:#f92672">*</span>a <span style="color:#f92672">+</span> C<span style="color:#f92672">.</span>λ<span style="color:#f92672">*</span>b
</span></span></code></pre></div><h3 id="mutation">Mutation<a hidden class="anchor" aria-hidden="true" href="#mutation">#</a></h3>
<p>Mutation introduces random changes to individuals to maintain genetic diversity within the population. Common mutation method is zero-mean Gaussian distribution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">abstract type</span> <span style="color:#66d9ef">MutationMethod</span> <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">DistributionMutation</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">MutationMethod</span>
</span></span><span style="display:flex;"><span>    λ <span style="color:#75715e"># mutation rate</span>
</span></span><span style="display:flex;"><span>    D <span style="color:#75715e"># mutation distribution</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> mutate(M<span style="color:#f92672">::</span><span style="color:#66d9ef">DistributionMutation</span>, child)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [rand() <span style="color:#f92672">&lt;</span> M<span style="color:#f92672">.</span>λ <span style="color:#f92672">?</span> v <span style="color:#f92672">+</span> rand(M<span style="color:#f92672">.</span>D) <span style="color:#f92672">:</span> v <span style="color:#66d9ef">for</span> v <span style="color:#66d9ef">in</span> child]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GaussianMutation(σ) <span style="color:#f92672">=</span> DistributionMutation(<span style="color:#ae81ff">1.0</span>, Normal(<span style="color:#ae81ff">0</span>,σ))
</span></span></code></pre></div><p>Each gene in the chromosome typically has a small probability λ of being changed. For a chromosome with m genes, this mutation rate is typically set to λ = 1/m, yielding an average of one mutation per child chromosome.</p>
<p><img alt="Gaussian Mutation" loading="lazy" src="/picture/population_method09.png"></p>
<h2 id="differential-evolution">Differential Evolution<a hidden class="anchor" aria-hidden="true" href="#differential-evolution">#</a></h2>
<p>Differential Evolution (DE) is a population-based optimization algorithm that utilizes vector differences for perturbing the population members.</p>
<p>For each individual x:</p>
<ol>
<li>Select three distinct individuals a, b, and c from the population.</li>
<li>Generate a trial vector by adding the weighted difference between b and c to a:
$$
v = a + F \cdot (b - c)
$$
where F is a scaling factor typically in the range [0, 2].</li>
<li>Evaluate the fitness of the trial vector v. If v has a better fitness than x, replace x with v in the next generation; otherwise, retain x.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">mutable struct</span> <span style="color:#66d9ef">DifferentialEvolution</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">PopulationMethod</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#75715e"># crossover probability</span>
</span></span><span style="display:flex;"><span>    w <span style="color:#75715e"># differential weight</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>init!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">DifferentialEvolution</span>, f, designs) <span style="color:#f92672">=</span> designs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> step!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">DifferentialEvolution</span>, f, population)
</span></span><span style="display:flex;"><span>    p, w <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>p, M<span style="color:#f92672">.</span>w
</span></span><span style="display:flex;"><span>    n, m <span style="color:#f92672">=</span> length(population[<span style="color:#ae81ff">1</span>]), length(population)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> population
</span></span><span style="display:flex;"><span>        a, b, c <span style="color:#f92672">=</span> sample(population, <span style="color:#ae81ff">3</span>, replace<span style="color:#f92672">=</span>false)
</span></span><span style="display:flex;"><span>        z <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> w<span style="color:#f92672">*</span>(b<span style="color:#f92672">-</span>c)
</span></span><span style="display:flex;"><span>        x′ <span style="color:#f92672">=</span> crossover(UniformCrossover(p), x, z)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> f(x′) <span style="color:#f92672">&lt;</span> f(x)
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">.=</span> x′
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> population
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><img alt="Differential Evolution" loading="lazy" src="/picture/population_method10.png"></p>
<h2 id="particle-swarm-optimization">Particle Swarm Optimization<a hidden class="anchor" aria-hidden="true" href="#particle-swarm-optimization">#</a></h2>
<p>Particle swarm optimization introduces momentum to accelerate convergence toward minima. Each individual, or particle, in the population keeps track of its current position, velocity, and the best position it has seen so far. Momentum allows an individual to accumulate speed in a favorable direction, independent of local perturbations.</p>
<p>At each iteration, each individual is accelerated toward both the best position it has seen and the best position found thus far by any individual. The acceleration is weighted by a random term.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">mutable struct</span> <span style="color:#66d9ef">Particle</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#75715e"># position</span>
</span></span><span style="display:flex;"><span>    v <span style="color:#75715e"># velocity</span>
</span></span><span style="display:flex;"><span>    x_best <span style="color:#75715e"># best design thus far</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mutable struct</span> <span style="color:#66d9ef">ParticleSwarm</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">PopulationMethod</span>
</span></span><span style="display:flex;"><span>    w <span style="color:#75715e"># inertia</span>
</span></span><span style="display:flex;"><span>    c1 <span style="color:#75715e"># first momentum coefficient</span>
</span></span><span style="display:flex;"><span>    c2 <span style="color:#75715e"># second momentum coefficient</span>
</span></span><span style="display:flex;"><span>    V <span style="color:#75715e"># initial particle velocity distribution</span>
</span></span><span style="display:flex;"><span>    best <span style="color:#75715e"># best overall design thus far, and its value</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> init!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">ParticleSwarm</span>, f, designs)
</span></span><span style="display:flex;"><span>    population <span style="color:#f92672">=</span> [Particle(x,rand(M<span style="color:#f92672">.</span>V),copy(x)) <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> designs]
</span></span><span style="display:flex;"><span>    best <span style="color:#f92672">=</span> (x<span style="color:#f92672">=</span>copy(population[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>x), y<span style="color:#f92672">=</span>Inf)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> P <span style="color:#66d9ef">in</span> population
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> f(P<span style="color:#f92672">.</span>x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> y <span style="color:#f92672">&lt;</span> best<span style="color:#f92672">.</span>y; best <span style="color:#f92672">=</span> (x<span style="color:#f92672">=</span>P<span style="color:#f92672">.</span>x, y<span style="color:#f92672">=</span>y); <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    M<span style="color:#f92672">.</span>best <span style="color:#f92672">=</span> best
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> population
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> step!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">ParticleSwarm</span>, f, population)
</span></span><span style="display:flex;"><span>    w, c1, c2, best <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>w, M<span style="color:#f92672">.</span>c1, M<span style="color:#f92672">.</span>c2, M<span style="color:#f92672">.</span>best
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> length(best<span style="color:#f92672">.</span>x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> P <span style="color:#66d9ef">in</span> population
</span></span><span style="display:flex;"><span>        r1, r2 <span style="color:#f92672">=</span> rand(n), rand(n)
</span></span><span style="display:flex;"><span>        P<span style="color:#f92672">.</span>x <span style="color:#f92672">+=</span> P<span style="color:#f92672">.</span>v
</span></span><span style="display:flex;"><span>        P<span style="color:#f92672">.</span>v <span style="color:#f92672">=</span> w<span style="color:#f92672">*</span>P<span style="color:#f92672">.</span>v <span style="color:#f92672">+</span> c1<span style="color:#f92672">*</span>r1<span style="color:#f92672">.*</span>(P<span style="color:#f92672">.</span>x_best <span style="color:#f92672">-</span> P<span style="color:#f92672">.</span>x) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>              c2<span style="color:#f92672">*</span>r2<span style="color:#f92672">.*</span>(best<span style="color:#f92672">.</span>x <span style="color:#f92672">-</span> P<span style="color:#f92672">.</span>x)
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> f(P<span style="color:#f92672">.</span>x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> y <span style="color:#f92672">&lt;</span> best<span style="color:#f92672">.</span>y; best <span style="color:#f92672">=</span> (x<span style="color:#f92672">=</span>copy(P<span style="color:#f92672">.</span>x), y<span style="color:#f92672">=</span>y); <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> y <span style="color:#f92672">&lt;</span> f(P<span style="color:#f92672">.</span>x_best); P<span style="color:#f92672">.</span>x_best <span style="color:#f92672">.=</span> P<span style="color:#f92672">.</span>x; <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    M<span style="color:#f92672">.</span>best <span style="color:#f92672">=</span> best
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> population
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><img alt="Particle Swarm Optimization" loading="lazy" src="/picture/population_method11.png"></p>
<h2 id="firefly-algorithm">Firefly Algorithm<a hidden class="anchor" aria-hidden="true" href="#firefly-algorithm">#</a></h2>
<p>The firefly algorithm was inspired by the manner in which fireflies flash their lights to attract mates of the same species. In the firefly algorithm, each individual in the population is a firefly and can flash to attract other fireflies.</p>
<p>At each iteration, all fireflies are moved toward all more attractive fireflies. A firefly&rsquo;s attraction is proportional to its performance.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">Firefly</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">PopulationMethod</span>
</span></span><span style="display:flex;"><span>    α <span style="color:#75715e"># walk step size</span>
</span></span><span style="display:flex;"><span>    β <span style="color:#75715e"># source intensity</span>
</span></span><span style="display:flex;"><span>    brightness <span style="color:#75715e"># intensity function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>init!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">Firefly</span>, f, designs) <span style="color:#f92672">=</span> designs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> step!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">Firefly</span>, f, population)
</span></span><span style="display:flex;"><span>    α, β, brightness <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>α, M<span style="color:#f92672">.</span>β, M<span style="color:#f92672">.</span>brightness
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> length(population[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    N <span style="color:#f92672">=</span> MvNormal(I(m))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> a <span style="color:#66d9ef">in</span> population, b <span style="color:#66d9ef">in</span> population
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> f(b) <span style="color:#f92672">&lt;</span> f(a)
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">=</span> norm(b<span style="color:#f92672">-</span>a)
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">.+=</span> β<span style="color:#f92672">*</span>brightness(r)<span style="color:#f92672">*</span>(b<span style="color:#f92672">-</span>a) <span style="color:#f92672">+</span> α<span style="color:#f92672">*</span>rand(N)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> population
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><img alt="Firefly Algorithm" loading="lazy" src="/picture/population_method12.png"></p>
<h2 id="cuckoo-search">Cuckoo Search<a hidden class="anchor" aria-hidden="true" href="#cuckoo-search">#</a></h2>
<p>Cuckoo search is another nature-inspired algorithm named after the cuckoo bird, which engages in a form of brood parasitism. Cuckoos lay their eggs in the nests of other birds.</p>
<p>In cuckoo search, each nest represents a design point. New design points can be produced using Lévy flights from nests, which are random walks with step-lengths from a heavy-tailed distribution (typically a Cauchy distribution).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">mutable struct</span> <span style="color:#66d9ef">CuckooSearch</span> <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">PopulationMethod</span>
</span></span><span style="display:flex;"><span>    p_s <span style="color:#75715e"># search fraction</span>
</span></span><span style="display:flex;"><span>    p_a <span style="color:#75715e"># nest abandonment fraction</span>
</span></span><span style="display:flex;"><span>    C <span style="color:#75715e"># flight distribution</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> init!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">CuckooSearch</span>, f, designs)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [(x<span style="color:#f92672">=</span>x, y<span style="color:#f92672">=</span>f(x)) <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> designs]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> step!(M<span style="color:#f92672">::</span><span style="color:#66d9ef">CuckooSearch</span>, f, population)
</span></span><span style="display:flex;"><span>    p_s, p_a, C <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>p_s, M<span style="color:#f92672">.</span>p_a, M<span style="color:#f92672">.</span>C
</span></span><span style="display:flex;"><span>    m, n <span style="color:#f92672">=</span> length(population), length(population[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>x)
</span></span><span style="display:flex;"><span>    m_search <span style="color:#f92672">=</span> round(<span style="color:#66d9ef">Int</span>, m<span style="color:#f92672">*</span>p_s)
</span></span><span style="display:flex;"><span>    m_abandon <span style="color:#f92672">=</span> round(<span style="color:#66d9ef">Int</span>, m<span style="color:#f92672">*</span>p_a)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m_search
</span></span><span style="display:flex;"><span>        j, k <span style="color:#f92672">=</span> rand(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m), rand(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m)
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> population[j]<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> rand(C,n)
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> f(x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> y <span style="color:#f92672">&lt;</span> population[k]<span style="color:#f92672">.</span>y
</span></span><span style="display:flex;"><span>            population[k] <span style="color:#f92672">=</span> (x<span style="color:#f92672">=</span>x, y<span style="color:#f92672">=</span>y)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> sortperm(population, by<span style="color:#f92672">=</span>nest<span style="color:#f92672">-&gt;</span>nest<span style="color:#f92672">.</span>y, rev<span style="color:#f92672">=</span>true)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m_abandon
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> rand(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m<span style="color:#f92672">-</span>m_abandon)<span style="color:#f92672">+</span>m_abandon
</span></span><span style="display:flex;"><span>        x′ <span style="color:#f92672">=</span> population[p[j]]<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> rand(C,n)
</span></span><span style="display:flex;"><span>        population[p[i]] <span style="color:#f92672">=</span> (x<span style="color:#f92672">=</span>x′, y<span style="color:#f92672">=</span>f(x′))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> population
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><img alt="Cuckoo Search" loading="lazy" src="/picture/population_method13.png"></p>
<h2 id="hybrid-methods">Hybrid Methods<a hidden class="anchor" aria-hidden="true" href="#hybrid-methods">#</a></h2>
<p>Many population methods perform well in global search, being able to avoid local minima and finding the best regions of the design space. Unfortunately, these methods do not perform as well in local search in comparison to descent methods.</p>
<p>Several hybrid methods have been developed to extend population methods with descent-based features to improve their performance in local search.</p>
<ul>
<li>In <strong>Lamarckian learning</strong>, the population method is extended with a local search method that locally improves each individual. The original individual and its objective function value are replaced by the individual’s optimized counterpart.</li>
<li>In <strong>Baldwinian learning</strong>, the same local search method is applied to each individual, but the results are used only to update the individual’s objective function value. Individuals are not replaced but are merely associated with optimized objective function values.</li>
</ul>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>Population methods are powerful optimization techniques that leverage a collection of design points to explore the design space effectively. By utilizing mechanisms inspired by natural processes, such as genetic algorithms, differential evolution, and particle swarm optimization, these methods can navigate complex landscapes and avoid local minima. Hybrid approaches that combine population methods with local search techniques further enhance their performance, making them versatile tools for solving a wide range of optimization problems.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/programming/">Programming</a></li>
      <li><a href="http://localhost:1313/tags/population-method/">Population Method</a></li>
      <li><a href="http://localhost:1313/tags/mathematical-modeling/">Mathematical Modeling</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Timothy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
